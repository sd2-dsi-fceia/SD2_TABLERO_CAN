//$file${.::bsp.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: MEF_kl46z.qm
// File:  ${.::bsp.c}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
// All your changes in these sections will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::bsp.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Board Support Package implementation for desktop OS (Windows, Linux, MacOS)
#include "qpc.h"    // QP/C real-time embedded framework
#include "bsp.h"    // Board Support Package interface
#include <stdio.h>  // for printf()/fprintf()
#include <stdlib.h> // for exit()

#include "board.h"
#include "fsl_debug_console.h"

//............................................................................
// BSP functions...
//............................................................................
void BSP_init(void) {
	printf("Simple Blinky example\n\r"
			"QP/C version: %s\n\r",
	QP_VERSION_STR);
}
//............................................................................
void BSP_start(void) {
	// Initialize event pools --> utilizar cuando generamos eventos externos
	static QF_MPOOL_EL(QEvt)
	smlPoolSto[10];
	QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));

	// no need to initialize publish-subscribe
//	QActive_psInit(subscrSto, Q_DIM(subscrSto));

// instantiate and start AOs/threads...
	static QEvt const *MEFQueueSto[10];

	// Constructor de los objetos activos
	MEF_ctor();

	// Inicia los objetos activos
	QACTIVE_START(AO_MEF, 1U,   	// QP prio. of the AO
			MEFQueueSto,			// event queue storage
			Q_DIM(MEFQueueSto),		// queue length [events]
			(void *)0, 0U,          // no stack storage
			(void *)0);				// no initialization param
}
//............................................................................
void BSP_ledOff(void) {
	printf("LED OFF\n\r");
	LED_RED_OFF();
}
//............................................................................
void BSP_ledOn(void) {
	printf("LED ON\n\r");
	LED_RED_ON();
}

// callback functions needed by the framework --------------------------------
void QF_onStartup(void) {
	LED_RED_INIT(LOGIC_LED_ON);
	LED_RED_ON();
	SysTick_Config(CLOCK_GetCoreSysClkFreq() / 1000U);
}
void QF_onCleanup(void) {
}
void QF_onClockTick(void) {
//	QF_TICK_X(0U, (void *)0); // QF clock tick processing for rate 0
}
Q_NORETURN Q_onError(char const *const module, int id) {
	PRINTF("Assertion failed in %s:%d\n\r", module, id);
	PRINTF("ERROR!!!\n\rRevisar funciones de eventos,atributos,...\n\r");

	// NOTE: this implementation of the error handler is intended only
	// for debugging and MUST be changed for deployment of the application
	// (assuming that you ship your production code with assertions enabled).
	Q_UNUSED_PAR(module);
	Q_UNUSED_PAR(id);
	QS_ASSERTION(module, id, 10000U);

#ifndef NDEBUG
	// light up the user LED
	LED_GREEN_ON();
	// for debugging, hang on in an endless loop...
	for (;;) {
	}
#endif

	NVIC_SystemReset();
}
void QV_onIdle(void) { /* entered with interrupts DISABLED, see NOTE01 */
#ifdef Q_SPY
#elif defined NDEBUG
    // Put the CPU and peripherals to the low-power mode.
    // you might need to customize the clock management for your application,
    // see the datasheet for your particular Cortex-M MCU.
    //
    // !!!CAUTION!!!
    // QV_CPU_SLEEP() contains the WFI instruction, which stops the CPU
    // clock, which unfortunately disables the JTAG port, so the ST-Link
    // debugger can no longer connect to the board. For that reason, the call
    // to QV_CPU_SLEEP() has to be used with CAUTION.
    //
    // NOTE: If you find your board "frozen" like this, strap BOOT0 to VDD and
    // reset the board, then connect with ST-Link Utilities and erase the part.
    // The trick with BOOT(0) is it gets the part to run the System Loader
    // instead of your broken code. When done disconnect BOOT0, and start over.
    //
    //QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
    QF_INT_ENABLE(); // for now, just enable interrupts
#else
	QF_INT_ENABLE(); // just enable interrupts
#endif
}
void SysTick_Handler(void) {
	// process time events at rate 0
	QTIMEEVT_TICK_X(0U, (void *)0);
}

