//$file${.::Nodo_2.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: Nodo2.qm
// File:  ${.::Nodo_2.c}
//
// This code has been generated by QM 6.1.1 <www.state-machine.com/qm>.
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
// All your changes in these sections will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::Nodo_2.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/**
 * @file Nodo_2.c
 * @date 14/09/24
 * @brief Funciones y variables propias del Nodo 2.
 */

#include "Nodo_2.h"

#include "qpc.h"

#include "can.h"
#include "CanApi.h"

#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"

#include "clock_config.h"
#include "MKL46Z4.h"
#include "fsl_debug_console.h"

#define CAN_NODO_2_ID	20

#define BOARD_LED_RED_GPIO_PIN_MASK (1U << 29U)

#define LUZ_MIN	500
#define LUZ_MAX	1500
#define LED_ON	GPIO_ClearPinsOutput(BOARD_LED_RED_GPIO,BOARD_LED_RED_GPIO_PIN_MASK)
#define LED_OFF	GPIO_SetPinsOutput(BOARD_LED_RED_GPIO, BOARD_LED_RED_GPIO_PIN_MASK)

typedef union
{
	struct
	{
		unsigned LED_ROJO :1;
		unsigned PULSADOR1 :1;
		unsigned PULSADOR2 :1;
		unsigned RESERVADO :5;
	};
	uint8_t data;
} EstPerifericos_t;

/**
 * @brief Mensaje 1 de can.
 */
struct can_frame canMsg1;
/**
 * @brief Mensaje de lectura.
 */
struct can_frame canMsgRead =
{ .can_dlc = 0, .can_id = 0, };
static uint16_t TimeoutError = 0;

/**
 * @brief Procesa la informacion leida.
 */
static void canmsg_sensorLuz(void);
/**
 * @brief Funcion de callback para nodo 1 (id = 10).
 * @param[in] SubcriberId Id del nodo origen.
 * @param[in] nodeId Id del nodo que se quiere recibir la informacion.
 */
static void Callback_Nodo1(canid_t SubcriberId, canid_t nodeId);
/**
 * @brief Funcion de callback si termina el timeout.
 */
extern void callbackTimeout(void);

//---------------------------------------------------------------------------------------
extern void Nodo2_init(void)
{
	/* Inicializacion del can. */
	CAN_init();

	/* Configuro los filtros y mascaras para la recepcion. */
	Error_Can_t result = CAN_setMask(MASK0, false, 0x7FF); // Máscara 0x7FF, no extendido (ID estándar)
	if (result != ERROR_CAN_OK) {
		PRINTF("\n\rError: al configurar la mascara.\n\r");
	}

	result = CAN_setFilter(RXF0, false, 10); // Filtro para ID 20, no extendido (ID estándar)
	if (result != ERROR_CAN_OK) {
		PRINTF("\n\rError: al configurar el filtro.\n\r");
	}

	/* Identificador del nodo 2. */
	canMsg1.can_id = CAN_NODO_2_ID;
	canMsg1.can_dlc = 1;

	/* Crea una subscripcion. */
	Error_Can_t error = CAN_Subscribe(10, canMsg1.can_id, Callback_Nodo1);
	assert(error != ERROR_CAN_MEMORY);

	return;
}
//---------------------------------------------------------------------------------------
extern void Nodo2_writeToBus(void)
{
	Error_Can_t estado;

	EstPerifericos_t perifericos =
	{ .data = 0 };

	perifericos.LED_ROJO = ~GPIO_ReadPinInput(BOARD_LED_RED_GPIO,
			BOARD_LED_RED_PIN);
	perifericos.PULSADOR1 = ~GPIO_ReadPinInput(BOARD_SW1_GPIO, BOARD_SW1_PIN);
	perifericos.PULSADOR2 = ~GPIO_ReadPinInput(BOARD_SW3_GPIO, BOARD_SW3_PIN);

	canMsg1.data[0] = perifericos.data;
	canMsg1.can_dlc = 1;

	estado = CAN_sendMsg(&canMsg1);

	if (estado == ERROR_CAN_OK)
	{
		PRINTF("\n\rMensaje enviado\n\r");
		PRINTF("ID\tDLC\tDATA\n\r");
		PRINTF("%d\t%d\t", canMsg1.can_id, canMsg1.can_dlc);

		for (uint8_t i = 0; i < 8; i++)
		{
			PRINTF("%d ", canMsg1.data[i]);
		}
		PRINTF("\n\r");
	}
	else
	{
		if (estado == ERROR_CAN_QUEUETX_FULL)
			PRINTF("\n\rError: buffers de transmision llenos.\n\r");
	}

	return;
}
//---------------------------------------------------------------------------------------
extern void Nodo2_serialPort(void)
{
	PRINTF("\n\rMensaje de recepcion\n\r");
	PRINTF("ID\tDLC\tDATA\n\r");
	PRINTF("%d\t%d\t", canMsgRead.can_id, canMsgRead.can_dlc);

	for (uint8_t i = 0; i < 8; i++)
	{
		PRINTF("%d ", canMsgRead.data[i]);
	}

	PRINTF("\n\r");

	return;
}
//---------------------------------------------------------------------------------------
extern void Nodo2_xtransfer(void)
{
	/*
	 * Si el spi es lento esto puede demorar por lo que se recomienda
	 * quitar CAN_eventTx de la rutina del systick. Se esta utilizando
	 * solo para prueba.
	 *
	 * En entorno de depuracion ambas funciones generan una señal de error
	 * si no hay eventos disponibles por lo que pueden utilizarse para verificar.
	 * En este caso no vamos a utilizarlas.
	 */
	if (CAN_getTimer())
	{
		CAN_eventTx();
		CAN_eventRx();
	}

	return;
}
//---------------------------------------------------------------------------------------
extern void callbackTimeout(void)
{
	// Acciones si sucede esto
	CAN_init();	// Reinicio el modulo si fuese necesario

	/* Configuro los filtros y mascaras para la recepcion. */
	Error_Can_t result = CAN_setMask(MASK0, false, 0x7FF); // Máscara 0x7FF, no extendido (ID estándar)
	if (result != ERROR_CAN_OK) {
		PRINTF("\n\rError: al configurar la mascara.\n\r");
	}

	result = CAN_setFilter(RXF0, false, 10); // Filtro para ID 20, no extendido (ID estándar)
	if (result != ERROR_CAN_OK) {
		PRINTF("\n\rError: al configurar el filtro.\n\r");
	}

	LED_GREEN_TOGGLE();

	TimeoutError++;
	PRINTF("\n\rError por timeout numero %d",TimeoutError);

	return;
}
//---------------------------------------------------------------------------------------
extern void setSerieEvt(void);

static void Callback_Nodo1(canid_t SubcriberId, canid_t nodeId)
{
	/*
	 * RECOMENDACIONES DE USO DE CALLBACKS: Importante mantener
	 * las funciones de callback lo mas cortas posible y evitar
	 * el uso de rutinas que demoren tiempo como PRINTF.
	 */
	Error_Can_t error = CAN_readMsg(&canMsgRead, nodeId, SubcriberId);
	if (error != ERROR_CAN_OK)
	{
		if (error == ERROR_CAN_NOT_FOUND)
			PRINTF("\n\rError: no se encuentra el id del nodo destino.\n\r");
		if (error == ERROR_CAN_QUEUERX_EMPTY)
			PRINTF("\n\rError: no hay datos en el buffer.\n\r");
	}

	canmsg_sensorLuz();

	setSerieEvt(); // Genera el evento SERIE
//	Rx_msgFlag = true;	// Solo utilizado para printear el mensaje en el loop infinito y no
			// dentro de la callback.

	return;
}
//---------------------------------------------------------------------------------------
static void canmsg_sensorLuz(void)
{
	uint16_t adc_read;

	if (canMsgRead.can_id == 10)
	{
		adc_read = canMsgRead.data[1];
		adc_read = (adc_read << 8) | canMsgRead.data[0];

		if (adc_read > LUZ_MAX)
			LED_ON;
		if (adc_read < LUZ_MIN)
			LED_OFF;
	}

	return;
}

