<?xml version="1.0" encoding="UTF-8"?>
<model version="6.1.1" links="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.state-machine.com/qm/qm.xsd">
 <documentation>About this example:
-------------------
Simple &quot;Blinky&quot; console application for workstations (Windows, Linux, MacOS)
(see &quot;QM Tutorial&quot; at: https://www.state-machine.com/qm/gs_tut.html)

This example demonstrates:
- Active object (Blinky) with state machine
- Board Support Package abstraction for portability
- BSP implementation for desktop OS (Windows, Linux, MacOS)
- Platform-independent main() function
- Makefile to build the generated code on desktop OS (Windows, Linux, MacOS)
- Customized tools for building the generated code directly from QM

Building the example:
---------------------
To build this example, you will need the QP/C framework installed on your computer and the GNU-GCC compiler. Both of them will be available if you install the QP-bundle from:

https://www.state-machine.com/#Downloads

Running the example:
--------------------
This example is a simple console application, which you can run from a terminal.

For more QM examples for QP/C see:
https://www.state-machine.com/qpc/exa.html</documentation>
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${Shared}-->
 <package name="Shared" stereotype="0x00">
  <!--${Shared::Nodo3Signals}-->
  <attribute name="Nodo3Signals" type="enum" visibility="0x04" properties="0x00">
   <code>{
    TIMEOUT_SIG = Q_USER_SIG,
    TIMEOUT_RX_SIG,
    TIME_300MS_SIG,
    RESET_CAN_SIG,
};</code>
  </attribute>
  <!--${Shared::AO_Nodo3}-->
  <attribute name="AO_Nodo3" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;Nodo3_inst.super;</code>
  </attribute>
  <!--${Shared::Nodo3_ctor}-->
  <operation name="Nodo3_ctor" type="void" visibility="0x00" properties="0x01">
   <documentation>The Blinky &quot;constructor&quot; is provided outside of the Blinky class, so that it can be used independently from the class. This is part of the &quot;opaque pointer&quot; design idiom.</documentation>
   <code>Nodo3 * const me = &amp;Nodo3_inst;
QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Nodo3_initial));

/* Arma el evento de tiempo de 500ms. */
QTimeEvt_ctorX(&amp;me-&gt;timeEvt, &amp;me-&gt;super, TIMEOUT_SIG, 0U);

/* Arma el evento de tiempo de 300ms. */
QTimeEvt_ctorX(&amp;me-&gt;Evt_time300ms, &amp;me-&gt;super, TIME_300MS_SIG, 0U);

/* Arma el evento de tiempo de 3s. */
//QTimeEvt_ctorX(&amp;me-&gt;Evt_time3s, &amp;me-&gt;super, RESET_CAN_SIG, 0U);</code>
  </operation>
 </package>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::Nodo3}-->
  <class name="Nodo3" superclass="qpc::QActive">
   <!--${AOs::Nodo3::timeEvt}-->
   <attribute name="timeEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::Nodo3::inst}-->
   <attribute name="inst" type="Nodo3" visibility="0x00" properties="0x01"/>
   <!--${AOs::Nodo3::Evt_time300ms}-->
   <attribute name="Evt_time300ms" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::Nodo3::Evt_time3s}-->
   <attribute name="Evt_time3s" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::Nodo3::SM}-->
   <statechart properties="0x03">
    <documentation>Maquinas de estados del nodo 3.</documentation>
    <!--${AOs::Nodo3::SM::initial}-->
    <initial target="../1">
     <action brief="init"/>
     <initial_glyph conn="8,4,5,0,13,3">
      <action box="1,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::Nodo3::SM::Modo_Normal}-->
    <state name="Modo_Normal">
     <documentation>Modo normal de trabajo</documentation>
     <!--${AOs::Nodo3::SM::Modo_Normal::initial}-->
     <initial target="../3">
      <action brief="init">QTimeEvt_armX(&amp;me-&gt;timeEvt,
BSP_TICKS_PER_SEC, BSP_TICKS_PER_SEC);</action>
      <initial_glyph conn="6,12,5,0,13,2">
       <action box="0,-2,6,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::Nodo3::SM::Modo_Normal::history}-->
     <history type="deep" target="../3">
      <history_glyph conn="38,17,1,1,-8,3,-3"/>
     </history>
     <!--${AOs::Nodo3::SM::Modo_Normal::TIMEOUT_RX}-->
     <tran trig="TIMEOUT_RX" target="../../2/0">
      <action>/* Activamos el temporizador de 300ms. */
QTimeEvt_armX(&amp;me-&gt;Evt_time300ms,
BSP_TICKS_300MS/3 , BSP_TICKS_300MS/3);

LED_RED_OFF();

/* Activamos el temporizador de 3s. */
//QTimeEvt_armX(&amp;me-&gt;Evt_time3s,
//BSP_TICKS_3S, BSP_TICKS_3S);</action>
      <tran_glyph conn="38,13,1,3,10,3,15">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::Nodo3::SM::Modo_Normal::off}-->
     <state name="off">
      <documentation>Estado de led off</documentation>
      <entry brief="Apaga led">BSP_ledOff();</entry>
      <!--${AOs::Nodo3::SM::Modo_Normal::off::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../../4">
       <tran_glyph conn="10,25,3,3,-2,8,2">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="10,14,17,13">
       <entry box="1,2,11,3"/>
      </state_glyph>
     </state>
     <!--${AOs::Nodo3::SM::Modo_Normal::Escritura}-->
     <state name="Escritura">
      <documentation>Estado de salida de datos por serie</documentation>
      <entry brief="Prende led y enviar datos">/* Prendemos el led. */
BSP_ledOn();

/* Enviamos la informacion a la app. */
Nodo3_salidaSerie();</entry>
      <!--${AOs::Nodo3::SM::Modo_Normal::Escritura::TIMEOUT}-->
      <tran trig="TIMEOUT" target="../../3">
       <tran_glyph conn="10,38,3,1,20,-16,-3">
        <action box="0,-2,9,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="10,29,17,12">
       <entry box="1,2,12,5"/>
      </state_glyph>
     </state>
     <state_glyph node="4,7,34,37"/>
    </state>
    <!--${AOs::Nodo3::SM::Modo_Error}-->
    <state name="Modo_Error">
     <documentation>Modo de error</documentation>
     <!--${AOs::Nodo3::SM::Modo_Error::timeout}-->
     <state name="timeout">
      <documentation>Ingresa cuando existe un timeout</documentation>
      <entry brief="Acciones"/>
      <!--${AOs::Nodo3::SM::Modo_Error::timeout::RESET_CAN}-->
      <tran trig="RESET_CAN" target="../../../1" cpref="../../../1/1">
       <action>// Se activa luego de 3 segundos
/* Desactivamos los temporizadores. */
QTimeEvt_disarm(&amp;me-&gt;Evt_time300ms);
//QTimeEvt_disarm(&amp;me-&gt;Evt_time3s);

LED_GREEN_OFF();</action>
       <tran_glyph conn="63,20,3,1,-21,-3,-3">
        <action box="-21,-2,10,2"/>
       </tran_glyph>
      </tran>
      <!--${AOs::Nodo3::SM::Modo_Error::timeout::TIME_300MS}-->
      <tran trig="TIME_300MS">
       <action brief="Toggle Led Verde">/* Togglea el led verde. */
LED_GREEN_TOGGLE();</action>
       <tran_glyph conn="63,27,3,-1,14">
        <action box="0,-5,14,5"/>
       </tran_glyph>
      </tran>
      <state_glyph node="63,13,17,16">
       <entry box="1,2,11,3"/>
      </state_glyph>
     </state>
     <state_glyph node="58,7,26,37"/>
    </state>
    <state_diagram size="90,50"/>
   </statechart>
  </class>
  <!--${AOs::setEvt_Timeout}-->
  <operation name="setEvt_Timeout" type="void" visibility="0x00" properties="0x00">
   <code>// Crear el evento din치micamente
QEvt *evtTimeout = Q_NEW(QEvt, TIMEOUT_RX_SIG);  // El evento INICIO_SIG

// Postear el evento a la m치quina de estados de Blinky
QACTIVE_POST(AO_Nodo3, evtTimeout, 0);</code>
  </operation>
  <!--${AOs::setEvt_ResetCan}-->
  <operation name="setEvt_ResetCan" type="void" visibility="0x00" properties="0x00">
   <documentation>Se activa cuando se recibe informacion luego del reinicio.</documentation>
   <code>// Crear el evento din치micamente
QEvt *evtResetCan = Q_NEW(QEvt, RESET_CAN_SIG);  // El evento RESET_CAN_SIG

// Postear el evento a la m치quina de estados de Blinky
QACTIVE_POST(AO_Nodo3, evtResetCan, 0);</code>
  </operation>
 </package>
 <!--${.}-->
 <directory name=".">
  <!--${.::bsp.h}-->
  <file name="bsp.h">
   <text>#ifndef BSP_H_
#define BSP_H_

#define BSP_TICKS_PER_SEC    500U
#define BSP_TICKS_300MS      300U
#define BSP_TICKS_3S         3000U

void BSP_init(void);
void BSP_start(void);
void BSP_ledOn(void);
void BSP_ledOff(void);

$declare ${Shared}

#endif // BSP_H_</text>
  </file>
  <!--${.::bsp.c}-->
  <file name="bsp.c">
   <text>// Board Support Package implementation for desktop OS (Windows, Linux, MacOS)
#include &quot;qpc.h&quot;    // QP/C real-time embedded framework
#include &quot;bsp.h&quot;    // Board Support Package interface
#include &lt;stdio.h&gt;  // for printf()/fprintf()
#include &lt;stdlib.h&gt; // for exit()

#include &quot;board.h&quot;
#include &quot;peripherals.h&quot;
#include &quot;clock_config.h&quot;
#include &quot;MKL46Z4.h&quot;
#include &quot;pin_mux.h&quot;
#include &quot;fsl_debug_console.h&quot;

void assert_failed(char const * const module, int_t const id); // prototype

//............................................................................
void BSP_init(void)   {
    // Sin acciones por aca. ;)
    PRINTF(&quot;\n\rNombre: Nodo 3\n\r&quot;);
    PRINTF(&quot;Descripcion: Este nodo se encarga de recibir&quot;
            &quot;datos desde el modulo can y luego msotrar&quot;
            &quot;en un puerto serie dicho resultados.\n\r&quot;);
    PRINTF(&quot;Materia: Sistemas digitales 2\n\r&quot;);
    PRINTF(&quot;\n\r&quot;);
}
//............................................................................
#define MAX_POOL_SIZE    15
static QF_MPOOL_EL(QEvt) smlPoolSto[MAX_POOL_SIZE];

void BSP_start(void) {
    // Need to initialize event pools for events
    //static QF_MPOOL_EL(QEvt) smlPoolSto[10];
    //QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(smlPoolSto[0]));
    QF_poolInit(smlPoolSto, sizeof(smlPoolSto), sizeof(QEvt));

    // no need to initialize publish-subscribe
    //QActive_psInit(subscrSto, Q_DIM(subscrSto));

    // instantiate and start AOs/threads...

    static QEvt const *Nodo3QueueSto[15];

    Nodo3_ctor();

    QACTIVE_START(AO_Nodo3,
        1U,                          // QP prio. of the AO
        Nodo3QueueSto,              // event queue storage
        Q_DIM(Nodo3QueueSto),       // queue length [events]
        (void *)0, 0U,               // no stack storage
        (void *)0);                  // no initialization param
}
//............................................................................
void BSP_ledOff(void) {
    //PRINTF(&quot;LED OFF\n&quot;);
    LED_RED_OFF();
}
//............................................................................
void BSP_ledOn(void)  {
    //PRINTF(&quot;LED ON\n&quot;);
    LED_RED_ON();
}

// callback functions needed by the framework --------------------------------
void QF_onStartup(void) {}
//............................................................................
void QF_onCleanup(void) {}
//............................................................................
void QF_onClockTick(void) {
    //QF_TICK_X(0U, (void *)0); // QF clock tick processing for rate 0
}
void Q_onError(char const * const module, int id) {
    PRINTF(&quot;Assertion failed in %s:%d&quot;, module, id);
    exit(-1);
}
//............................................................................
void QV_onIdle(void) { /* entered with interrupts DISABLED, see NOTE01 */
#if defined NDEBUG
     /* Put the CPU and peripherals to the low-power mode */
    QV_CPU_SLEEP(); /* atomically go to sleep and enable interrupts */
#else
    QF_INT_ENABLE(); /* just enable interrupts */
#endif
}
//............................................................................
void assert_failed(char const * const module, int_t const id) {
    Q_onError(module, id);
}</text>
  </file>
  <!--${.::Nodo3_SM.c}-->
  <file name="Nodo3_SM.c">
   <text>#include &quot;Nodo3_SM.h&quot;
#include &quot;qpc.h&quot;    // QP/C real-time embedded framework
#include &quot;bsp.h&quot;    // Board Support Package interface

#include &quot;board.h&quot;
#include &quot;peripherals.h&quot;
#include &quot;pin_mux.h&quot;
#include &quot;clock_config.h&quot;
#include &quot;MKL46Z4.h&quot;
#include &quot;fsl_debug_console.h&quot;

#include &quot;Nodo3_QP.h&quot;

// ask QM to declare the Blinky class
$declare ${AOs::Nodo3}

$define ${Shared}

$define ${AOs::Nodo3}

$define ${AOs::setEvt_Timeout}
$define ${AOs::setEvt_ResetCan}</text>
  </file>
  <!--${.::main.c}-->
  <file name="main.c">
   <text>#include &quot;qpc.h&quot;                 // QP/C real-time embedded framework
#include &quot;bsp.h&quot;                 // Board Support Package
#include &quot;Nodo3_QP.h&quot;            // Archivo del nodo 3

#include &lt;stdio.h&gt;
#include &quot;board.h&quot;
#include &quot;peripherals.h&quot;
#include &quot;pin_mux.h&quot;
#include &quot;clock_config.h&quot;
#include &quot;MKL46Z4.h&quot;
#include &quot;fsl_debug_console.h&quot;

//............................................................................
int main() {
    /* Init board hardware. */
    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitBootPeripherals();
#ifndef BOARD_INIT_DEBUG_CONSOLE_PERIPHERAL
    /* Init FSL debug console. */
    BOARD_InitDebugConsole();
#endif

    /* Configuracion de los led y botones */
    BOARD_InitLEDs();
    BOARD_InitButtons();

    /* Incializamos todos los parametros de can. */
    Nodo3_reset_can();

    SysTick_Config(CLOCK_GetCoreSysClkFreq() / 1000U);

    QF_init();       // initialize the framework and the underlying RT kernel
    BSP_init();      // initialize the BSP
    BSP_start();     // start the AOs/Threads
    return QF_run(); // run the QF application
}
//............................................................................
void SysTick_Handler(void)
{
    QF_TICK_X(0U, (void *)0); // QF clock tick processing for rate 0

    Nodo3_xtransfer();

    return;
}
</text>
  </file>
  <!--${.::Makefile}-->
  <file name="Makefile">
   <text># Makefile for building QP/C application on Windows and POSIX hosts
#
# examples of invoking this Makefile:
# building configurations: Debug (default), Release, and Spy
# make
# make CONF=rel
# make CONF=spy
# make clean   # cleanup the build
# make CONF=spy clean   # cleanup the build
#
# NOTE:
# To use this Makefile on Windows, you will need the GNU make utility, which
# is included in the QTools collection for Windows, see:
#    http://sourceforge.net/projects/qpc/files/QTools/
#

#-----------------------------------------------------------------------------
# project name:
#
PROJECT := blinky

#-----------------------------------------------------------------------------
# project directories:
#

# list of all source directories used by this project
VPATH := . \

# list of all include directories needed by this project
INCLUDES := -I. \

# location of the QP/C framework (if not provided in an env. variable)
ifeq ($(QPC),)
QPC := /qp/qpc
endif

#-----------------------------------------------------------------------------
# project files:
#

# C source files...
C_SRCS := \
    blinky.c \
    bsp.c \
    main.c

# C++ source files...
CPP_SRCS :=

LIB_DIRS :=
LIBS     :=

# defines...
# QP_API_VERSION controls the QP API compatibility; 9999 means the latest API
DEFINES   := -DQP_API_VERSION=9999

ifeq (,$(CONF))
    CONF := dbg
endif

#-----------------------------------------------------------------------------
# add QP/C framework:
#
C_SRCS += \
    qep_hsm.c \
    qep_msm.c \
    qf_act.c \
    qf_actq.c \
    qf_defer.c \
    qf_dyn.c \
    qf_mem.c \
    qf_ps.c \
    qf_qact.c \
    qf_qeq.c \
    qf_qmact.c \
    qf_time.c \
    qf_port.c

QS_SRCS := \
    qs.c \
    qs_64bit.c \
    qs_rx.c \
    qs_fp.c \
    qs_port.c

ifeq ($(OS),Windows_NT)

# NOTE:
# For Windows hosts, you can choose:
# - the single-threaded QP/C port (win32-qv) or
# - the multithreaded QP/C port (win32).
#
QP_PORT_DIR := $(QPC)/ports/win32-qv
#QP_PORT_DIR := $(QPC)/ports/win32
LIBS += -lws2_32

else

# NOTE:
# For POSIX hosts (Linux, MacOS), you can choose:
# - the single-threaded QP/C port (win32-qv) or
# - the multithreaded QP/C port (win32).
#
QP_PORT_DIR := $(QPC)/ports/posix-qv
#QP_PORT_DIR := $(QPC)/ports/posix
LIBS += -lpthread

endif

#============================================================================
# Typically you should not need to change anything below this line

VPATH    += $(QPC)/src/qf $(QP_PORT_DIR)
INCLUDES += -I$(QPC)/include -I$(QP_PORT_DIR)

#-----------------------------------------------------------------------------
# GNU toolset:
#
# NOTE:
# GNU toolset (MinGW) is included in the QTools collection for Windows, see:
#     https://www.state-machine.com/qtools
# It is assumed that %QTOOLS%\bin directory is added to the PATH
#
CC    := gcc
CPP   := g++
LINK  := gcc    # for C programs
#LINK  := g++   # for C++ programs

#-----------------------------------------------------------------------------
# basic utilities (depends on the OS this Makefile runs on):
#
ifeq ($(OS),Windows_NT)
    MKDIR      := mkdir
    RM         := rm
    TARGET_EXT := .exe
else ifeq ($(OSTYPE),cygwin)
    MKDIR      := mkdir -p
    RM         := rm -f
    TARGET_EXT := .exe
else
    MKDIR      := mkdir -p
    RM         := rm -f
    TARGET_EXT :=
endif

#-----------------------------------------------------------------------------
# build configurations...

ifeq (rel, $(CONF)) # Release configuration ..................................

BIN_DIR := build_rel
# gcc options:
CFLAGS  = -c -O3 -fno-pie -std=c11 -pedantic -Wall -Wextra -W \
    $(INCLUDES) $(DEFINES) -DNDEBUG

CPPFLAGS = -c -O3 -fno-pie -std=c++11 -pedantic -Wall -Wextra \
    -fno-rtti -fno-exceptions \
    $(INCLUDES) $(DEFINES) -DNDEBUG

else ifeq (spy, $(CONF))  # Spy configuration ................................

BIN_DIR := build_spy

C_SRCS   += $(QS_SRCS)
VPATH    += $(QPC)/src/qs

# gcc options:
CFLAGS  = -c -g -O -fno-pie -std=c11 -pedantic -Wall -Wextra -W \
    $(INCLUDES) $(DEFINES) -DQ_SPY

CPPFLAGS = -c -g -O -fno-pie -std=c++11 -pedantic -Wall -Wextra \
    -fno-rtti -fno-exceptions \
    $(INCLUDES) $(DEFINES) -DQ_SPY

else # default Debug configuration .........................................

BIN_DIR := build

# gcc options:
CFLAGS  = -c -g -O -fno-pie -std=c11 -pedantic -Wall -Wextra -W \
    $(INCLUDES) $(DEFINES)

CPPFLAGS = -c -g -O -fno-pie -std=c++11 -pedantic -Wall -Wextra \
    -fno-rtti -fno-exceptions \
    $(INCLUDES) $(DEFINES)

endif  # .....................................................................

ifndef GCC_OLD
    LINKFLAGS := -no-pie
endif

#-----------------------------------------------------------------------------
C_OBJS       := $(patsubst %.c,%.o,   $(C_SRCS))
CPP_OBJS     := $(patsubst %.cpp,%.o, $(CPP_SRCS))

TARGET_EXE   := $(BIN_DIR)/$(PROJECT)$(TARGET_EXT)
C_OBJS_EXT   := $(addprefix $(BIN_DIR)/, $(C_OBJS))
C_DEPS_EXT   := $(patsubst %.o,%.d, $(C_OBJS_EXT))
CPP_OBJS_EXT := $(addprefix $(BIN_DIR)/, $(CPP_OBJS))
CPP_DEPS_EXT := $(patsubst %.o,%.d, $(CPP_OBJS_EXT))

#-----------------------------------------------------------------------------
# rules
#

.PHONY: clean show

all: $(TARGET_EXE)

$(TARGET_EXE) : $(C_OBJS_EXT) $(CPP_OBJS_EXT)
    $(CC) $(CFLAGS) $(QPC)/src/qs/qstamp.c -o $(BIN_DIR)/qstamp.o
    $(LINK) $(LINKFLAGS) $(LIB_DIRS) -o $@ $^ $(BIN_DIR)/qstamp.o $(LIBS)

$(BIN_DIR)/%.d : %.c
    $(CC) -MM -MT $(@:.d=.o) $(CFLAGS) $&lt; &gt; $@

$(BIN_DIR)/%.d : %.cpp
    $(CPP) -MM -MT $(@:.d=.o) $(CPPFLAGS) $&lt; &gt; $@

$(BIN_DIR)/%.o : %.c
    $(CC) $(CFLAGS) $&lt; -o $@

$(BIN_DIR)/%.o : %.cpp
    $(CPP) $(CPPFLAGS) $&lt; -o $@

# create BIN_DIR and include dependencies only if needed
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),show)
ifneq ($(MAKECMDGOALS),debug)
ifeq (&quot;$(wildcard $(BIN_DIR))&quot;,&quot;&quot;)
$(shell $(MKDIR) $(BIN_DIR))
endif
-include $(C_DEPS_EXT) $(CPP_DEPS_EXT)
endif
endif
endif

clean :
    -$(RM) $(BIN_DIR)/*.o \
    $(BIN_DIR)/*.d \
    $(TARGET_EXE)

show :
    @echo PROJECT      = $(PROJECT)
    @echo TARGET_EXE   = $(TARGET_EXE)
    @echo VPATH        = $(VPATH)
    @echo C_SRCS       = $(C_SRCS)
    @echo CPP_SRCS     = $(CPP_SRCS)
    @echo C_DEPS_EXT   = $(C_DEPS_EXT)
    @echo C_OBJS_EXT   = $(C_OBJS_EXT)
    @echo C_DEPS_EXT   = $(C_DEPS_EXT)
    @echo CPP_DEPS_EXT = $(CPP_DEPS_EXT)
    @echo CPP_OBJS_EXT = $(CPP_OBJS_EXT)
    @echo LIB_DIRS     = $(LIB_DIRS)
    @echo LIBS         = $(LIBS)
    @echo DEFINES      = $(DEFINES)
</text>
  </file>
  <!--${.::Nodo3_QP.c}-->
  <file name="Nodo3_QP.c" properties="external"/>
  <!--${.::Nodo3_QP.h}-->
  <file name="Nodo3_QP.h" properties="external"/>
  <!--${.::Nodo3_SM.h}-->
  <file name="Nodo3_SM.h">
   <text>#ifndef _INCLUDE_NODO3_SM_H_
#define _INLCUDE_NODO3_SM_H_

$declare ${AOs::setEvt_Timeout}
$declare ${AOs::setEvt_ResetCan}

#endif</text>
  </file>
 </directory>
</model>
